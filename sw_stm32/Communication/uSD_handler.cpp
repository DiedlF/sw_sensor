/** *****************************************************************************
 * @file    	uSD_handler.cpp
 * @brief   	uSD File reader + writer
 * @author  	Dr. Klaus Schaefer,  some adaptions by Maximilian Betz
 * @copyright 	Copyright 2021 Dr. Klaus Schaefer. All rights reserved.
 * @license 	This project is released under the GNU Public License GPL-3.0

    <Larus Flight Sensor Firmware>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.

 **************************************************************************/

#include "system_configuration.h"
#include "main.h"
#include "FreeRTOS_wrapper.h"
#include "fatfs.h"
#include "common.h"
#include "ascii_support.h"
#include "git-commit-version.h"  /* generated by a git post commit hook in /githooks.  */
#include "Linear_Least_Square_Fit.h"
#include "data_structures.h"
#include "read_configuration_file.h"
#include "communicator.h"
#include "emergency.h"
#include "EEPROM_data_file_implementation.h"
#include "uSD_handler.h"
#include "watchdog_handler.h"
#include "magnetic_induction_report.h"
#include "persistent_data_file.h"
#include "system_state.h"
#include "reminder_flag.h"
#include "uSD_helpers.h"

COMMON reminder_flag perform_after_landing_actions;

extern Semaphore setup_file_handling_completed;

COMMON bool dump_sensor_readings;

COMMON FATFS fatfs;
extern SD_HandleTypeDef hsd;
extern DMA_HandleTypeDef hdma_sdio_rx;
extern DMA_HandleTypeDef hdma_sdio_tx;
extern uint64_t FAT_time; //!< DOS FAT time for file usage

extern RestrictedTask uSD_handler_task;

//!< this executable takes care of all uSD reading and writing
void uSD_handler_runnable (void*)
{
restart:

  HAL_SD_DeInit (&hsd);
  if(! BSP_PlatformIsDetected())
    {
      recover_and_initialize_flash();
      (void) ensure_EEPROM_parameter_integrity();
      setup_file_handling_completed.signal(); // give up waiting for configuration
      watchdog_activator.signal(); // now start the watchdog

  while(true) // wait until uSD plugged in and restart the uSD handler afterwards
	{
	  delay(1000);
	  if( BSP_PlatformIsDetected())
	    goto restart;
	}
    }

  delay(500); // ensure that there is some wait time after inserting a sd-card
  HAL_StatusTypeDef hresult = HAL_SD_Init (&hsd);
  if( hresult != HAL_OK)
    goto restart;

  FRESULT fresult;
  fresult = f_mount (&fatfs, "", 0);

  if (fresult != FR_OK)
    {
      setup_file_handling_completed.signal();
      watchdog_activator.signal(); // now start the watchdog

      while(true) // wait until uSD UN-plugged
	{
	  delay(1000);
	  if( ! BSP_PlatformIsDetected())
	    break;
	}
      while(true) // wait until uSD plugged in and restart the uSD handler afterwards
	{
	  if( BSP_PlatformIsDetected())
	    goto restart;
	  delay(1000);
	}
    }

  // LED on to signal "uSD active"
  HAL_GPIO_WritePin (LED_STATUS1_GPIO_Port, LED_STATUS2_Pin, GPIO_PIN_SET);

  if( read_software_update())
      {
      *( ( volatile uint32_t * ) 0xe000ed94 ) = 0; // MPU off
      __asm volatile ( "dsb" ::: "memory" );
      __asm volatile ( "isb" );
      typedef void(*pFunction)(void);
      pFunction copy_function_address = *(pFunction *)0x06001c;
      copy_function_address();
      }

  uSD_handler_task.set_priority(configMAX_PRIORITIES - 1); // set it to highest priority
  recover_and_initialize_flash();
  uSD_handler_task.set_priority(LOGGER_PRIORITY); // set normal priority

  // read configuration file if it is present on the SD card
  bool init_file_read = read_init_file( "larus_sensor_config.ini");

  // if it has been used: rename it to prevent overwriting something in the future
  if( init_file_read)
    f_rename ("larus_sensor_config.ini", "larus_sensor_config.ini.used");

  (void) ensure_EEPROM_parameter_integrity();

  drop_privileges(); // go protected

  watchdog_activator.signal(); // now start the watchdog

  setup_file_handling_completed.signal();

  delay( 100); // give communicator a moment to initialize

  FIL the_file;

  fresult = f_open (&the_file, (char *)"sensor.readings", FA_READ);
  dump_sensor_readings = (fresult == FR_OK);
  f_close( &the_file); // as this is just a dummy file

  FILINFO filinfo;
  fresult = f_stat("logger", &filinfo);
  if( (fresult != FR_OK) || ((filinfo.fattrib & AM_DIR)==0))
    while( 1)
	{
	notify_take (true); // wait for synchronization by crash detection
	if( crashfile && ! user_initiated_reset)
	  write_crash_dump();
	}

  char out_filename[30];

  // wait until a GNSS timestamp is available.
  while ( coordinates.sat_fix_type == 0)
    {
      if( crashfile && ! user_initiated_reset)
	  write_crash_dump();
      delay (100);
    }

  // repeat writing log files for all successive flights
  while(true)
    {
      // generate filename based on timestamp
      char * next = out_filename;

      fresult = f_stat("eeprom", &filinfo);
      if( (fresult != FR_OK) || ((filinfo.fattrib & AM_DIR)!=0))
	{
	  append_string( next, "eeprom/");
	  next = format_date_time( next, coordinates);
	  acquire_privileges(); //reading sensitive flash sections
	  write_EEPROM_dump( out_filename); // now we have date+time, start logging
	  drop_privileges();
	}

      next = out_filename;
      append_string( next, "logger/");
      next = format_date_time( next, coordinates);
      append_string( next, ".lrsx");

      bool success = flex_file.open(out_filename);
      if ( not success)
	{
	  while( true)
	    {
		notify_take (true); // wait for synchronization by crash detection
		if( crashfile && ! user_initiated_reset)
		  write_crash_dump();
	    }
	}

      // repeat: fill buffer with data chunks, write it to uSD and copy remaining data to start of buffer
      // this logger loop is synchronized by the communicator object
      while( true)
	{
	  notify_take (true); // wait for synchronization by from communicator OR by the crash detection mechanism

	  if( crashfile && ! user_initiated_reset)
	    {
	      flex_file.close();
	      write_crash_dump();
	    }

	  HAL_GPIO_WritePin (LED_STATUS1_GPIO_Port, LED_STATUS2_Pin, GPIO_PIN_SET);
	  success = flex_file.flush_buffer();
	  success &= flex_file.sync_file();
	  HAL_GPIO_WritePin (LED_STATUS1_GPIO_Port, LED_STATUS2_Pin, GPIO_PIN_RESET);

	  if( not success)
	      {
	      flex_file.close(); // at least: try to ...

	      HAL_GPIO_WritePin (LED_STATUS1_GPIO_Port, LED_STATUS2_Pin, GPIO_PIN_RESET);
	      while( true)
		{
		notify_take (true); // wait for synchronization by crash detection
		if( crashfile && ! user_initiated_reset)
		  write_crash_dump();
		}
	      }

	  if( perform_after_landing_actions.test_and_reset())
	    {
	      flex_file.block_input(); // avoid buffer overrun
	      flex_file.close();

	      delay(250); // just to be sure everything is written
	      break; /* break inner while loop and start again, which will start a new set of logfiles */
	    }
	}
    }
}

#define STACKSIZE 2048
uint32_t __ALIGNED(STACKSIZE*4) uSD_stack_buffer[STACKSIZE];

static TaskParameters_t p =
  { uSD_handler_runnable, "uSD",
  STACKSIZE, 0,
  LOGGER_PRIORITY + portPRIVILEGE_BIT,
  uSD_stack_buffer,
    {
      { COMMON_BLOCK, COMMON_SIZE, portMPU_REGION_READ_WRITE },
      { (void *)0x080C0000, 0x00040000, portMPU_REGION_READ_WRITE}, // EEPROM
      { 0, 0, 0}
      } 
    };

COMMON RestrictedTask uSD_handler_task (p);

void sync_logger(void)
  {
    uSD_handler_task.notify_give ();
  }

//!< this function is called synchronously from task context
extern "C" void emergency_write_crashdump( char * file, int line)
  {
  acquire_privileges();
  crashfile=file;
  crashline=line;
  extern void * pxCurrentTCB;
  register_dump.active_TCB = pxCurrentTCB;
  uSD_handler_task.set_priority(configMAX_PRIORITIES - 1); // set it to highest priority
  uSD_handler_task.notify_give();
  suspend();
  }

COMMON bool watchdog_has_been_triggered = false;
COMMON bool user_initiated_reset = false;

//!< helper task to stop everything and launch emergency logging
void kill_amok_running_task( void *)
{
  while ( 0 == register_dump.active_TCB)
    suspend();

  // red warning LED on
  HAL_GPIO_WritePin ( LED_ERROR_GPIO_Port, LED_ERROR_Pin, GPIO_PIN_SET);

  vTaskSuspend( (TaskHandle_t)(register_dump.active_TCB)); // probably the amok running task

  if( watchdog_has_been_triggered)
    watchdog_handler.suspend(); // avoid WWDG reset out of phase if already activated

  uSD_handler_task.set_priority(configMAX_PRIORITIES - 1); // set it to highest priority
  uSD_handler_task.notify_give();
  while( true) // job done
    suspend();
}

RestrictedTask amok_running_task_killer( kill_amok_running_task, "ANTI_AMOK", configMINIMAL_STACK_SIZE, 0, configMAX_PRIORITIES -1);

//!< this function is called in exception context
extern "C" void finish_crash_handling( void)
{
  extern void * pxCurrentTCB;
  register_dump.active_TCB = pxCurrentTCB;

  // remember what happened
  crashfile=(char *)"EXCEPTION";
  crashline=0;

  // triggger error logging
  uSD_handler_task.notify_give_from_ISR();
  amok_running_task_killer.resume_from_ISR();
}

//!< this function is called if the watchdog has been woken up
extern "C" void handle_watchdog_trigger( void)
{
  extern void * pxCurrentTCB;
  register_dump.active_TCB = pxCurrentTCB;

  // remember what happened
  crashfile=(char *)"WATCHDOG";
  crashline=0;

  watchdog_has_been_triggered = true;

  // triggger error logging
  uSD_handler_task.notify_give_from_ISR();
  amok_running_task_killer.resume_from_ISR();
}
